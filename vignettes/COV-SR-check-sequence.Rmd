Checking the CIDnetworks Suite: Covariates and Nodal Intercepts
========================================================

A.C. Thomas, November 22

 `r library(CIDnetworks)`

Here we test the fitting and plotting options for the COV and SR components, both on their own and together.

COV alone
---------

First, we test the COV component alone with three covariates.

```{r fig.width=8, fig.height=8}
n.nodes <- 100; covs <- 3
test.cov <- COV(n.nodes=n.nodes, covariates=matrix(rbinom(covs*n.nodes*(n.nodes-1)/2, 1, 0.5), ncol=3), coef.cov=1:covs, generate=TRUE)
test.cov.pieces <- test.cov$pieces(); test.cov.value <- test.cov$value()
test.cov.gibbs <- test.cov$gibbs.full(draws=500, report=500, burnin=200, thin=2, make.random.start=TRUE)
test.cov$gibbs.plot(test.cov.gibbs)
```

What are the performance characteristics of this sampler? First, we can manually extract each component's marginal draws:

```{r}
test.cov.gibbs.unlist <- list.output.to.matrices (test.cov.gibbs)
test.cov.gibbs.value <- test.cov$gibbs.value(test.cov.gibbs)
```

Plot the log-likelihood and one of the coefficient traces.

```{r fig.width=12, fig.height=6}
par(mfrow=c(1,2))
plot(test.cov.gibbs.unlist$log.lik, main="Log-likelihood")
plot(test.cov.gibbs.unlist$coef.cov[1,], main=paste("Coefficient 1", test.cov.pieces$coef.cov[1])); abline(h=test.cov.pieces$coef.cov[1], lwd=3, col=2)
```

How do the network values look compared to each other? Let's use the built-in plots in the class.

```{r fig.width=12, fig.height=6}
par(mfrow=c(1,2))
test.cov$plot.network(test.cov.value, main="Oracle Values")
test.cov$plot.network(apply(test.cov.gibbs.value, 1, mean), main="Mean Fitted Values")
```

Compare the fitted average value for each dyad with its generative counterpart.

```{r fig.width=8, fig.height=8}
plot(test.cov.value, apply(test.cov.gibbs.value, 1, mean))
```

Repeat, but this time when including the element as the sole component of a CID model.

```{r, fig.width=10, fig.height=10}
test.cov.g <- CID.generate (n.nodes=n.nodes, components=list(COV(covariates=matrix(rbinom(covs*n.nodes*(n.nodes-1)/2, 1, 0.5), ncol=3), coef.cov=1:covs)), intercept=1, residual.variance=2, generate=TRUE, class="gaussian")
test.cov.g.pieces <- test.cov.g$pieces()
test.cov.g.value <- test.cov.g$value()
test.cov.g.gibbs <- test.cov.g$gibbs.full(draws=300, report=300, burnin=300, make.random.start=TRUE)
par(mfrow=c(2,2))
test.cov.g$gibbs.plot(test.cov.g.gibbs)


test.cov.g.gibbs.value <- test.cov.g$gibbs.value(test.cov.g.gibbs)
color.range <- range(c(test.cov.g.value, apply(test.cov.g.gibbs.value, 1, mean)))
netplot(test.cov.g$edge.list, test.cov.g.value, colvalues=20, main="Oracle values", extremes=color.range)
netplot(test.cov.g$edge.list, apply(test.cov.g.gibbs.value, 1, mean), colvalues=20, main="Fitted values", extremes=color.range)
```

```{r fig.width=8, fig.height=8}
plot(test.cov.g.value, apply(test.cov.g.gibbs.value, 1, mean))
```


Now the binary within CID, which is the default mode:

```{r fig.width=8, fig.height=8}
test.cov.b <- CID.generate (n.nodes=n.nodes, components=list(COV(covariates=matrix(rbinom(covs*n.nodes*(n.nodes-1)/2, 1, 0.5), ncol=3), coef.cov=1:covs)), intercept=-3, residual.variance=2, generate=TRUE)
test.cov.b$plot.network(main="Outcomes on the Network Edges")
```

Looks good. Begin the fitting procedure!

```{r}
test.cov.b.pieces <- test.cov.b$pieces()
test.cov.b.value <- test.cov.b$value(redo=TRUE)

test.cov.b.gibbs <- test.cov.b$gibbs.full(draws=1000, report=500, burnin=1200, make.random.start=TRUE)
par(mfrow=c(2,2))
test.cov.b$gibbs.plot (test.cov.b.gibbs)

test.cov.b.gibbs.value <- test.cov.b$gibbs.value(test.cov.b.gibbs)
color.range <- range(c(test.cov.b.value, apply(test.cov.b.gibbs.value, 1, mean)))
netplot(test.cov.b$edge.list, test.cov.b.value, colvalues=20, main="Oracle values", extremes=color.range)
netplot(test.cov.b$edge.list, apply(test.cov.b.gibbs.value, 1, mean), colvalues=20, main="Fitted values", extremes=color.range)


plot(test.cov.b.value, apply(test.cov.b.gibbs.value, 1, mean))

```




SR Alone
---------

The sender/receiver effect should behave similarly to the covariates in its fitting, even with the shrinkage component considered. 



Test the base component first.

```{r fig.width=8, fig.height=8}
test.sr <- SR(n.nodes=n.nodes, intercept.sr.var=10, generate=TRUE)
test.sr$plot()
test.sr.pieces <- test.sr$pieces(); test.sr.value <- test.sr$value()
test.sr.gibbs <- test.sr$gibbs.full(draws=500, report=500, burnin=200, thin=2, make.random.start=TRUE)
```

How did we do?

```{r fig.width=8, fig.height=8}
test.sr.gibbs.unlist <- list.output.to.matrices (test.sr.gibbs)
test.sr.gibbs.value <- test.sr$gibbs.value(test.sr.gibbs)
plot(test.sr.gibbs.unlist$log.lik, main="Log-likelihood")
plot(test.sr.gibbs.unlist$intercept.sr.var, main=paste("SR Variance", test.sr.pieces$intercept.sr.var)); abline(h=test.sr.pieces$intercept.sr.var, lwd=3, col=2)
netplot(test.sr$edge.list, test.sr.value, colvalues=20, main="Oracle values")
netplot(test.sr$edge.list, apply(test.sr.gibbs.value, 1, mean), colvalues=20, main="Fitted values")
plot(test.sr.value, apply(test.sr.gibbs.value, 1, mean))
```




Now, Gaussian within CID:

```{r}
test.sr.g <- CID.generate (n.nodes, 
                           components=list(SR(4)), 
                           intercept=1, residual.variance=2, generate=TRUE)
test.sr.g.pieces <- test.sr.g$pieces()
test.sr.g.value <- test.sr.g$value()

test.sr.g.gibbs <- test.sr.g$gibbs.full(draws=300, report=300, burnin=300, make.random.start=TRUE)
par(mfrow=c(2,2))
test.sr.g$gibbs.plot(test.sr.g.gibbs)
```

```{r fig.width=12}
test.sr.g.gibbs.value <- test.sr.g$gibbs.value(test.sr.g.gibbs)

color.range <- range(c(test.sr.g.value, apply(test.sr.g.gibbs.value, 1, mean)))
netplot(test.sr.g$edge.list, test.sr.g.value, colvalues=20, main="Oracle values", extremes=color.range)
netplot(test.sr.g$edge.list, apply(test.sr.g.gibbs.value, 1, mean), colvalues=20, main="Fitted values", extremes=color.range)
plot(test.sr.g.value, apply(test.sr.g.gibbs.value, 1, mean))
```

Binary within CID:
```{r}
test.sr.b <- CID.generate (n.nodes, 
                           components=list(SR(4)), 
                           intercept=-1.5, residual.variance=2, generate=TRUE, class.outcome="binary")
test.sr.b.pieces <- test.sr.b$pieces()
test.sr.b.value <- test.sr.b$value()
```

First: does the network look good enough to test out?
```{r fig.width=8}
netplot(test.sr.b$edge.list, test.sr.b$outcome, colvalues=2, main="Oracle values", extremes=c(0,1))
```

Under this simulation, this looks sufficient. Run the Gibbs!

```{r}
test.sr.b.gibbs <- test.sr.b$gibbs.full(draws=1000, report=1000, burnin=500, make.random.start=TRUE)
test.sr.b$gibbs.plot(test.sr.b.gibbs)
```

```{r fig.width=12}
test.sr.b.gibbs.value <- test.sr.b$gibbs.value(test.sr.b.gibbs)

color.range <- range(c(test.sr.b.value, apply(test.sr.b.gibbs.value, 1, mean)))
netplot(test.sr.b$edge.list, test.sr.b.value, colvalues=20, main="Oracle values", extremes=color.range)
netplot(test.sr.b$edge.list, apply(test.sr.b.gibbs.value, 1, mean), colvalues=20, main="Fitted values", extremes=color.range)

plot(test.sr.b.value, apply(test.sr.b.gibbs.value, 1, mean))
```


COV and SR together
-------------------

Let's fit both components together.

```{r fig.width=8, fig.height=12}
cov.sr.g <- CID.generate (n.nodes, 
                          components=list(SR(4), 
                            COV(covariates=matrix(rbinom(covs*n.nodes*(n.nodes-1)/2, 1, 0.5), ncol=3), 
                                coef.cov=1:covs)), 
                          intercept=-1.5, residual.variance=2, generate=TRUE, class.outcome="gaussian")
par(mfrow=c(1,2)); cov.sr.g$plot()
cov.sr.g.pieces <- cov.sr.g$pieces()
cov.sr.g.value <- cov.sr.g$value()
cov.sr.g.gibbs <- cov.sr.g$gibbs.full(draws=1000, report=1000, burnin=500, make.random.start=TRUE)
par(mfrow=c(3,2)); cov.sr.g$gibbs.plot(cov.sr.g.gibbs)
```

Hurrah! Now the binary.

```{r fig.width=8, fig.height=12}
cov.sr.b <- CID.generate (n.nodes, 
                          components=list(SR(4), 
                            COV(covariates=matrix(rbinom(covs*n.nodes*(n.nodes-1)/2, 1, 0.5), ncol=3), 
                                coef.cov=1:covs)), 
                          intercept=-1.5, residual.variance=2, generate=TRUE)
par(mfrow=c(1,2)); cov.sr.b$plot()
cov.sr.b.pieces <- cov.sr.b$pieces()
cov.sr.b.value <- cov.sr.b$value()
cov.sr.b.gibbs <- cov.sr.b$gibbs.full(draws=1000, report=200, burnin=2000, thin=5, make.random.start=TRUE)
par(mfrow=c(3,2)); cov.sr.b$gibbs.plot(cov.sr.b.gibbs)
```




