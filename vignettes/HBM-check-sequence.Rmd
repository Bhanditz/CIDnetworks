Checking the CIDnetworks Suite: Hierarchical Block Model (hbm)
========================================================

A.C. Thomas, November 21

Hierarchical Block Model: Component Alone
---------------------------------------

The original Hierarchical Random Graph (Clauset, Moore and Newman 2008, Nature) worked on the premise that the nodes were embedded on a tree, and their common ancestor determines the value of the tie between them.

First, the component alone. Specify a model for simulation, create the data, and run the Gibbs sampler.

```{r}
library(CIDnetworks)
test.hbm <- HBM(5, n.nodes=60, block.value=c(0, -1, 1, -2, 2), generate=TRUE, residual.variance=0.0001, restrict.and.shift=FALSE)
test.hbm$plot()
test.hbm.pieces <- test.hbm$pieces()
test.hbm.value <- test.hbm$value()

test.hbm.gibbs <- test.hbm$gibbs.full(draws=500, report=500, burnin=500, thin=3, make.random.start=TRUE)
test.hbm$plot()

```

Now, process the output in a way that will be meaningful to testing the model.

```{r}
test.hbm.gibbs.unlist <- list.output.to.matrices (test.hbm.gibbs)
test.hbm.gibbs.value <- test.hbm$gibbs.value(test.hbm.gibbs)
```

Test each of the parameters. First, the log likelihood:

```{r fig.width=12}
plot(test.hbm.gibbs.unlist$log.lik, main="Log-likelihood")
```

How do the network values look?

```{r fig.width=12}
colrange <- range(c(test.hbm.value, apply(test.hbm.gibbs.value, 1, mean)))
netplot(test.hbm$edge.list, test.hbm.value, extremes=colrange, colvalues=20, main="Oracle values")
netplot(test.hbm$edge.list, apply(test.hbm.gibbs.value, 1, mean), extremes=colrange, colvalues=20, main="Fitted values")
plot(test.hbm.value, apply(test.hbm.gibbs.value, 1, mean))
```


Gaussian within CID:

```{r}
test.hbm.g <- CID.generate (100, components=list(HBM(2, block.value=c(1,-1))), intercept=1, residual.variance=0.02, generate=TRUE, class="gaussian")
test.hbm.g$plot()
test.hbm.g.pieces <- test.hbm.g$pieces()
test.hbm.g.value <- test.hbm.g$value()
test.hbm.g.gibbs <- test.hbm.g$gibbs.full(draws=300, report=100, burnin=300, thin=3, make.random.start=TRUE)
test.hbm.g$gibbs.plot(test.hbm.g.gibbs)
```

```{r fig.width=12}
test.hbm.g.gibbs.unwind <- list.output.to.matrices (test.hbm.g.gibbs)
test.hbm.g.gibbs.value <- test.hbm.g$gibbs.value(test.hbm.g.gibbs)

color.range <- range(c(test.hbm.g.value, apply(test.hbm.g.gibbs.value, 1, mean)))
netplot(test.hbm.g$edge.list, test.hbm.g.value, colvalues=20, main="Oracle values", extremes=color.range)
netplot(test.hbm.g$edge.list, apply(test.hbm.g.gibbs.value, 1, mean), colvalues=20, main="Fitted values", extremes=color.range)

plot(test.hbm.g.value, apply(test.hbm.g.gibbs.value, 1, mean))
```


Binary within CID:

```{r}
test.hbm.b <- CID.generate (100, components=list(HBM(2, block.value=c(1,-1))), intercept=0, generate=TRUE)
test.hbm.b.pieces <- test.hbm.b$pieces()
test.hbm.b.value <- test.hbm.b$value()

test.hbm.b.gibbs <- test.hbm.b$gibbs.full(draws=2000, report=100, burnin=500, thin=2, make.random.start=TRUE)
test.hbm.b$gibbs.plot (test.hbm.b.gibbs)
```

```{r fig.width=12}
test.hbm.b.gibbs.value <- test.hbm.b$gibbs.value(test.hbm.b.gibbs)

color.range <- range(c(test.hbm.b.value, apply(test.hbm.b.gibbs.value, 1, mean)))
netplot(test.hbm.b$edge.list, test.hbm.b.value, colvalues=20, main="Oracle values", extremes=color.range)
netplot(test.hbm.b$edge.list, apply(test.hbm.b.gibbs.value, 1, mean), colvalues=20, main="Fitted values", extremes=color.range)

plot(test.hbm.b.value, apply(test.hbm.b.gibbs.value, 1, mean));
```

