Checking the CIDnetworks Suite: Mixed Membership Stochastic Block Model (MMmmsbm)
========================================================

A.C. Thomas, November 21

Mixed Membership Stochastic Block Model: Component Alone
---------------------------------------

$Y_{ij} = S_{ij} B S_{ji}$

Component alone. Specify a model for simulation, create the data, and run the Gibbs sampler.

```{r}
library(CIDnetworks)
test.mmsbm <- MMSBM(2, n.nodes=50, b.vector=c(30,-10,10), generate=TRUE, residual.variance=0.0001, restrict.and.shift=FALSE, membership.alpha0=0.5)
test.mmsbm$plot()
test.mmsbm.pieces <- test.mmsbm$pieces()
test.mmsbm.value <- test.mmsbm$value()
test.mmsbm.loglike <- test.mmsbm$log.likelihood()
```

How is the membership mixing in the simulated case?

```{r}
table(c(test.mmsbm$membership.edge), c(test.mmsbm$edge.list))
```

What happens if we flatten it?

```{r}
test.mmsbm$draw(as.if.single=TRUE)
table(c(test.mmsbm$membership.edge), c(test.mmsbm$edge.list))
```

OK then. Now try running the Gibbs on the whole thing from scratch and check the log-likelihood.
```{r fig.width=12}
test.mmsbm.gibbs <- test.mmsbm$gibbs.full(draws=200, report=100, burnin=100, thin=1, make.random.start=TRUE)
test.mmsbm$plot(main="Last Draw")
test.mmsbm$gibbs.plot(test.mmsbm.gibbs)
test.mmsbm.gibbs.unlist <- list.output.to.matrices (test.mmsbm.gibbs)
test.mmsbm.gibbs.value <- test.mmsbm$gibbs.value(test.mmsbm.gibbs)
plot(test.mmsbm.gibbs.unlist$log.lik, main="Log-likelihood")
```

How do the network values look?

```{r fig.width=12}
colrange <- range(c(test.mmsbm.value, apply(test.mmsbm.gibbs.value, 1, mean)))
netplot(test.mmsbm$edge.list, test.mmsbm.value, extremes=colrange, colvalues=20, main="Oracle values")
netplot(test.mmsbm$edge.list, apply(test.mmsbm.gibbs.value, 1, mean), extremes=colrange, colvalues=20, main="Fitted values")
plot(test.mmsbm.value, apply(test.mmsbm.gibbs.value, 1, mean)); abline(a=0,b=1,col=2)
```

Test this Gibbs out with the Single Membership style to prime it. How does it do?

```{r}
primer <- test.mmsbm$gibbs.full(draws=600, report=100, burnin=10, thin=1, make.random.start=TRUE, as.if.single=TRUE)
primer.unlist <- list.output.to.matrices (primer)
plot(primer.unlist$log)
netplot(test.mmsbm$edge.list, test.mmsbm$value(), colvalues=20, main="Current")
netplot(test.mmsbm$edge.list, test.mmsbm.value, colvalues=20, main="Truth")

plot(jitter(test.mmsbm.value), jitter(test.mmsbm$value()))
#table(c(test.mmsbm$membership.edge), c(test.mmsbm$edge.list))
```

```{r}
test.mmsbm.gibbs <- test.mmsbm$gibbs.full(draws=600, report=100, burnin=50, thin=1, make.random.start=FALSE)
test.mmsbm$gibbs.plot(test.mmsbm.gibbs)
test.mmsbm.gibbs.unlist <- list.output.to.matrices (test.mmsbm.gibbs)
test.mmsbm.gibbs.value <- test.mmsbm$gibbs.value(test.mmsbm.gibbs)
plot(test.mmsbm.gibbs.unlist$log.lik, main="Log-likelihood")
```

How do the network values look?

```{r fig.width=12}
colrange <- range(c(test.mmsbm.value, apply(test.mmsbm.gibbs.value, 1, mean)))
netplot(test.mmsbm$edge.list, test.mmsbm.value, extremes=colrange, colvalues=20, main="Oracle values")
netplot(test.mmsbm$edge.list, apply(test.mmsbm.gibbs.value, 1, mean), extremes=colrange, colvalues=20, main="Fitted values")
plot(jitter(test.mmsbm.value), jitter(apply(test.mmsbm.gibbs.value, 1, mean)))
```

Gaussian within CID
-------------------

```{r}
test.mmsbm.g <- CID.generate (50, components=list(MMSBM(2, b.vector=c(15,-7,9))), intercept=1, residual.variance=0.02, generate=TRUE, class="gaussian")
test.mmsbm.g.pieces <- test.mmsbm.g$pieces()
test.mmsbm.g.value <- test.mmsbm.g$value()
test.mmsbm.g.gibbs <- test.mmsbm.g$gibbs.full(draws=300, report=100, burnin=300, make.random.start=TRUE)
test.mmsbm.g$gibbs.plot(test.mmsbm.g.gibbs)
#test.mmsbm.g$DIC(test.mmsbm.g.gibbs)
#repeat{test.mmsbm.g$draw(); print(test.mmsbm.g$pieces())}
```

```{r fig.width=12}
test.mmsbm.g.gibbs.unwind <- list.output.to.matrices (test.mmsbm.g.gibbs)
test.mmsbm.g.gibbs.value <- test.mmsbm.g$gibbs.value(test.mmsbm.g.gibbs)

#par(mfrow=c(3,2))
plot(test.mmsbm.g.gibbs.unwind$intercept, main="Intercept"); abline(h=test.mmsbm.g.pieces$intercept, col=2, lwd=3)

plot(test.mmsbm.g.gibbs.unwind$residual.variance, main="Residual Variance"); abline(h=test.mmsbm.g.pieces$residual.variance, col=2, lwd=3)
plot(test.mmsbm.g.gibbs.unwind$log.likelihood, main="Log Likelihood")

color.range <- range(c(test.mmsbm.g.value, apply(test.mmsbm.g.gibbs.value, 1, mean)))
netplot(test.mmsbm.g$edge.list, test.mmsbm.g.value, colvalues=20, main="Oracle values", extremes=color.range)
netplot(test.mmsbm.g$edge.list, apply(test.mmsbm.g.gibbs.value, 1, mean), colvalues=20, main="Fitted values", extremes=color.range)

plot(test.mmsbm.g.value, apply(test.mmsbm.g.gibbs.value, 1, mean))
```


Binary within CID:

```{r}
test.mmsbm.b <- CID.generate (40, components=list(MMSBM(2, b.vector=c(1,-1,1))), intercept=0, generate=TRUE, class.outcome="binary")
test.mmsbm.b
test.mmsbm.b$plot()
test.mmsbm.b.pieces <- test.mmsbm.b$pieces()
test.mmsbm.b.value <- test.mmsbm.b$value()

test.mmsbm.b.gibbs <- test.mmsbm.b$gibbs.full(draws=1000, report=100, burnin=0, thin=5, make.random.start=TRUE)
test.mmsbm.b$gibbs.plot(test.mmsbm.b.gibbs)
```

```{r fig.width=12}
test.mmsbm.b.gibbs.unwind <- list.output.to.matrices (test.mmsbm.b.gibbs)
test.mmsbm.b.gibbs.value <- test.mmsbm.b$gibbs.value(test.mmsbm.b.gibbs)

color.range <- range(c(test.mmsbm.b.value, apply(test.mmsbm.b.gibbs.value, 1, mean)))
netplot(test.mmsbm.b$edge.list, test.mmsbm.b.value, colvalues=20, main="Oracle values", extremes=color.range)
netplot(test.mmsbm.b$edge.list, apply(test.mmsbm.b.gibbs.value, 1, mean), colvalues=20, main="Fitted values", extremes=color.range)

plot(test.mmsbm.b.value, apply(test.mmsbm.b.gibbs.value, 1, mean)); abline(a=0,b=1,col=2,lwd=3)
```

