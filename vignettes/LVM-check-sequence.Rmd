Checking the CIDnetworks Suite: Latent Vector Model (LVM)
========================================================

A.C. Thomas, November 21

`r library(CIDnetworks)`

Latent Vector Model:
-------------------

Component alone. Specify a model for simulation, create the data, and run the Gibbs sampler.

```{r}
test.lvm <- LVM(2, n.nodes=10, generate=TRUE, residual.variance=0.0001)
test.lvm.pieces <- test.lvm$pieces()
test.lvm.value <- test.lvm$value()

test.lvm.gibbs <- test.lvm$gibbs.full(draws=500, report=100, burnin=100, thin=3, make.random.start=TRUE)
```

Now, process the output in a way that will be meaningful to testing the model.

```{r}
test.lvm.gibbs.unlist <- list.output.to.matrices (test.lvm.gibbs)
test.lvm.gibbs.value <- test.lvm$gibbs.value(test.lvm.gibbs)
```

Test each of the parameters. First, the log likelihood, then the multiplication factor:

```{r fig.width=12}
plot(test.lvm.gibbs.unlist$log.lik, main="Log-likelihood")
#plot(test.lvm.gibbs.unlist$mult.factor, main=paste("Multiplication Factor", test.lvm.pieces$mult.factor)); abline(h=test.lvm.pieces$mult.factor, lwd=3, col=2)
```

How do the network values look?

```{r fig.width=12}
colrange <- range(c(test.lvm.value, apply(test.lvm.gibbs.value, 1, mean)))
netplot(test.lvm$edge.list, test.lvm.value, extremes=colrange, colvalues=20, main="Oracle values")
netplot(test.lvm$edge.list, apply(test.lvm.gibbs.value, 1, mean), extremes=colrange, colvalues=20, main="Fitted values")
plot(test.lvm.value, apply(test.lvm.gibbs.value, 1, mean))
```


Gaussian within CID:

```{r}
test.lvm.g <- CID.generate (50, components=list(LVM(2, latent.vector.pos.V=diag(1,2))), intercept=1, residual.variance=0.02, generate=TRUE)
test.lvm.g.pieces <- test.lvm.g$pieces()
test.lvm.g.value <- test.lvm.g$value()
test.lvm.g.gibbs <- test.lvm.g$gibbs.full(draws=300, report=100, burnin=300, make.random.start=TRUE)
#repeat{test.lvm.g$draw(); print(test.lvm.g$pieces())}
```

```{r fig.width=12}
test.lvm.g.gibbs.unwind <- list.output.to.matrices (test.lvm.g.gibbs)
test.lvm.g.gibbs.value <- test.lvm.g$gibbs.value(test.lvm.g.gibbs)

#par(mfrow=c(3,2))
plot(test.lvm.g.gibbs.unwind$intercept, main="Intercept"); abline(h=test.lvm.g.pieces$intercept, col=2, lwd=3)

plot(test.lvm.g.gibbs.unwind$residual.variance, main="Residual Variance"); abline(h=test.lvm.g.pieces$residual.variance, col=2, lwd=3)
plot(test.lvm.g.gibbs.unwind$log.likelihood, main="Log Likelihood")

color.range <- range(c(test.lvm.g.value, apply(test.lvm.g.gibbs.value, 1, mean)))
netplot(test.lvm.g$edge.list, test.lvm.g.value, colvalues=20, main="Oracle values", extremes=color.range)
netplot(test.lvm.g$edge.list, apply(test.lvm.g.gibbs.value, 1, mean), colvalues=20, main="Fitted values", extremes=color.range)

plot(test.lvm.g.value, apply(test.lvm.g.gibbs.value, 1, mean))
```


Binary within CID:

```{r}
test.lvm.b <- CID.generate (100, components=list(LVM(2)), intercept=0, generate=TRUE, class.outcome="binary")
test.lvm.b.pieces <- test.lvm.b$pieces()
test.lvm.b.value <- test.lvm.b$value()

test.lvm.b.gibbs <- test.lvm.b$gibbs.full(draws=2000, report=100, burnin=0, make.random.start=TRUE)
```

```{r fig.width=12}
test.lvm.b.gibbs.unwind <- list.output.to.matrices (test.lvm.b.gibbs)
test.lvm.b.gibbs.value <- test.lvm.b$gibbs.value(test.lvm.b.gibbs)

plot(c(test.lvm.b.gibbs.unwind$intercept), main=paste("Intercept", test.lvm.b.pieces$intercept)); abline(h=test.lvm.b.pieces$intercept, col=2, lwd=3)

plot(c(test.lvm.b.gibbs.unwind$residual.variance), main="Residual Variance"); abline(h=test.lvm.b.pieces$residual.variance, col=2, lwd=3)
plot(c(test.lvm.b.gibbs.unwind$log.likelihood), main="Log Likelihood")

test.lvm.b.gibbs.unwind <- cut.burnin(test.lvm.b.gibbs.unwind, 500)
test.lvm.b.gibbs.value <- test.lvm.b.gibbs.value[,-(1:500)]

color.range <- range(c(test.lvm.b.value, apply(test.lvm.b.gibbs.value, 1, mean)))
netplot(test.lvm.b$edge.list, test.lvm.b.value, colvalues=20, main="Oracle values", extremes=color.range)
netplot(test.lvm.b$edge.list, apply(test.lvm.b.gibbs.value, 1, mean), colvalues=20, main="Fitted values", extremes=color.range)

plot(test.lvm.b.value, apply(test.lvm.b.gibbs.value, 1, mean)); abline(a=0,b=1,col=2,lwd=3)
```


